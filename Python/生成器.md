# yield 关键字初识
先看一个简单例子：
```
def yie():
    n = 1
    yield n
    print(n)
    n += 1
    yield n
    print(n)
    n += 1
    yield n
    print(n)


a = yie()
one = next(a)
print(f'one  {one}')
two = next(a)
print(f'two  {two}')
thr = next(a)
print(f'thr  {thr}')

# one  1
# 1
# two  2
# 2
# thr  3
```

当调用时，遇到 yield 关键字时函数和遇到 return 用类似的结果，返回一个值，但不同的是并没有退出函数，当下一次运行时，继续函数里后面的代码。
同时我们取值的方式比较特殊，通过 next() 去取对象的值，而这应该是属于迭代器的方法。

# 生成器函数（generator function）
如果函数包含至少一个 yield语句 (它可能包含其他 yield 或 return 语句)，那么它将成为一个生成器函数。

生成器函数与正常函数的差异下面列出的是生成器函数与正常函数的区别 ：
    当被调用时，它返回一个对象(迭代器)，但不会立即开始执行。
    __iter__() 和 __next__() 之类的方法将自动实现。所以可以使用 next() 迭代项目。
    一旦函数遇到 yield，该函数将被暂停，并将该控制权交给调用者。局部变量及其状态在连续调用之间被记住。
    最后，当函数终止时，StopIteration会在进一步的调用时自动引发。

上面例子中定义的 yie() 函数便是一个生成器函数。

# 生成器（generator）
而生成器即是生成器函数被调用后产生的对象。
如例子中的 a 便是一个生成器。
在每个调用之间函数会保持住变量n的值。与正常函数不同，当函数产生时，局部变量不会被销毁。 此外，生成器对象只能重复一次。
要重新启动该过程，需要使用类似于 a = yie() 的方法创建另一个生成器对象。

并且支持 for 循环遍历。

# 生成器推导式
使用生成器表达式，可以轻松创建简单的生成器。 它使构建生成器变得容易。
与 lambda 函数一样创建一个匿名函数，生成器表达式创建一个匿名生成函数。生成器表达式的语法与 Python 中的列表解析类似。 但方圆 [] 替换为圆括号 ()。
列表推导和生成器表达式之间的主要区别是：列表推导产生整个列表，生成器表达式一次生成一个项目。
它们是处理方式是懒惰的，只有在被要求时才能生产项目。 因此，生成器表达式的存储器效率高于等效列表的值。

```
ge = (i for i in range(10))
print(type(ge))

# <class 'generator'>
```

# yield from
语法：
    yield from generator



yield from 后面可以跟的可以是“ 生成器 、元组、 列表、range（）函数产生的序列等可迭代对象”
简单地说，yield from  generator 。实际上就是返回另外一个生成器。而yield只是返回一个元素。从这个层面来说，有下面的等价关系：yield from iterable本质上等于 for item in iterable: yield item 。

## TODO
深入的看着有点晕，暂时放放吧，留两个链接
https://blog.csdn.net/qq_27825451/article/details/85244237
https://www.cnblogs.com/wongbingming/p/9085268.html


# 生成器专属方法 send、throw、close
## send 方法详解
generator.send(value)

作用：向生成器发送一个值，随后恢复执行。
value 参数是 send 方法向生成器发送的值，这个值会作为当前所在的 yield 表达式的结果。
随后生成器恢复执行，直到下一个 yield，把它后面的值作为 send 方法的结果返回。

如果恢复执行后再也没有 yield 语句，生成器退出，并抛出 StopIteration 异常。

如果一开始使用 send 启动生成器，必须使用 None 作为参数，因为一开始没有可以接收值的 yield 表达式。
```
def gen():
    for i in range(2):
        x = yield i
        print('x:', x)

a = gen()
for _ in a:
    print(_)

# 0
# x: None
# 1
# x: None
```
不同于 return，yield 的值是可以进行赋值操作的，但是由于其特性，赋值在正常i情况下都为空。
如上面的例子，`x = yield i` 等式是从右向左的，当遇到 yield 时就抛出值，而下一次调用时才进行赋值，这时值已经不存在的，便为 None 了。

```
def gen():
    for i in range(2):
        x = yield i
        print('x:', x)

a = gen()
print(a.send(None)) # a.send(None) 等同于 next(a)
print(a.send(3))

# 0
# x: 3
# 1
```
这便是 send() 的用法，能够在使用生成器的使用根据需要传递值进去。

## throw 方法详解
generator.throw(type[, value[, traceback]])

作用：在生成器暂停的地方抛出类型为 type 的异常，并返回下一个 yield 的返回值。
如果生成器函数没有捕获并处理传入的异常，或者说抛出了另一个异常，那么该异常会被传递给调用方。
如果生成器退出时还没有 yield 新值，则会抛出 StopIteration 异常。

## （1 第一种情况：捕获并处理传入的异常，得到下一个 yield 的返回值。
```
def gen():
    n = 0
    while True:
        try:
            yield n
            n += 1
        except ZeroDivisionError:
            print('捕获到了 ZeroDivisionError')
            print('此时的 n 为：%s' % n)

g = gen()
ret = next(g)
print('第一次 yield 的返回值：%s' % ret)
ret = g.throw(ZeroDivisionError)
print(ret)

# 第一次 yield 的返回值：0
# 捕获到了 ZeroDivisionError
# 此时的 n 为：0
# 0

```
第一次调用时遇到 yield ,抛出值，第二次调用时接受到了异常，跳过了 n + 1，所以n保持为 0。
如果通过 throw 传入的异常被捕获的话，生成器能够恢复执行直到下一个 yield。


（1 如果捕获不准确的话
```
def gen():
    for i in range(5):
        try:
            yield i
        except Exception as e:
            print(e)

a = gen()
b = next(a) # a.send(None) 等同于 next(a)
print(b)
c = a.throw(ZeroDivisionError)
print(c)

# 0
#   (这样是捕获不到异常的，所以为空)
# 1
```

（2 甚至于不做捕获
```
def gen():
    for i in range(5):
        try:
            yield i
        except:
            print('error')

a = gen()
b = next(a) # a.send(None) 等同于 next(a)
print(b)
c = a.throw(ZeroDivisionError)
print(c)

# 0
# error
# 1
# error
# Exception ignored in: <generator object gen at 0x7fd7b72202e0>
# RuntimeError: generator ignored GeneratorExit
```


# 生成器优点
## 1. 容易实现
与其迭代器类相比，发生器可以以清晰简洁的方式实现。 
以下是使用迭代器类来实现2的幂次序的例子。
```
class PowTwo:
    def __init__(self, max = 0):
        self.max = max

    def __iter__(self):
        self.n = 0
        return self

    def __next__(self):
        if self.n > self.max:
            raise StopIteration

        result = 2 ** self.n
        self.n += 1
        return result
```

上面代码有点长，可以使用一个生成器函数实现同样的功能。
```
def PowTwoGen(max = 0):
    n = 0
    while n < max:
        yield 2 ** n
        n += 1
```
因为，生成器自动跟踪的细节，它更简洁，更干净。

## 2.内存高效
返回序列的正常函数将在返回结果之前会在内存中的创建整个序列。如果序列中的项目数量非常大，这可是要消耗内存的。
序列的生成器实现是内存友好的，并且是推荐使用的，因为它一次仅产生一个项目。

## 3. 表示无限流
生成器是表示无限数据流的绝佳媒介。 无限流不能存储在内存中，由于生成器一次只能生成一个项目，因此可以表示无限数据流。
以下示例可以生成所有偶数(至少在理论上)。
```
def all_even():
    n = 0
    while True:
        yield n
        n += 2
```

## 4.管道生成器
生成器可用于管理一系列操作，下面使用一个例子说明。
假设我们有一个快餐连锁店的日志文件。 日志文件有一列(第4列)，用于跟踪每小时销售的比萨饼数量，我们想算出在5年内销售的总萨饼数量。
假设一切都是字符串，不可用的数字标记为“N / A”。 这样做的生成器实现可以如下。
```
with open('sells.log') as file:
    pizza_col = (line[3] for line in file)
    per_hour = (int(x) for x in pizza_col if x != 'N/A')
    print("Total pizzas sold = ",sum(per_hour))
```
这种管道的方式是更高效和易于阅读的。



[Python生成器](https://www.yiibai.com/python/generator.html#article-start)
[python协程系列（三）——yield from原理详解](https://blog.csdn.net/qq_27825451/article/details/85244237)
[Python 生成器与它的 send，throw，close 方法](https://juejin.cn/post/6992917747973750821)