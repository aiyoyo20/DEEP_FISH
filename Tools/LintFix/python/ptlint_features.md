Pylint 特性
Pylint 跳棋的选项和开关

Pylint checkers 可以提供三组功能：

    控制它们执行的选项，

    他们可以提出的消息，

    他们可以生成的报告。

以下是所有检查器及其功能的列表。
异步检查器

检查器的逐字名称是 async.
异步检查消息

非异步上下文管理器（E1701） ：

    异步上下文管理器“%s”未实现 __aenter__ 和 __aexit__。 当异步上下文管理器与不包含的对象一起使用时使用 实现异步上下文管理协议。 这个消息不能 使用 Python < 3.5 时发出。
yield-inside-async-function (E1700) ：

    异步函数中的 Yield 语句时使用 yield 或 yield from 当在异步中发现 功能。 使用 Python < 3.5 时无法发出此消息。

Bad-Chained-Comparison 检查器

检查器的逐字名称是 bad-chained-comparison.
Bad-Chained-Comparison 检查器消息

坏链比较（W3601） ：

    使用语义不兼容的运算符（%s）进行可疑的 %s-part 链接比较 当存在链式比较时使用，其中一个表达式是两个表达式的一部分 属于不同语义组的比较（“<”并不意味着 与“is”相同，将它们链接在“0 < x is None”中可能是一个错误）。

基本检查器

检查器的逐字名称是 basic.

另请参阅 基本检查器选项的文档
基本检查消息

不在循环中（E0103） ：

    %r 没有正确地进入循环 在循环外使用 break 或 continue 关键字时使用。
功能重新定义 (E0102) ：

    %s 已经定义行 %s 在重新定义函数/类/方法时使用。
最后继续（E0116） ：

    “finally”子句中不支持“continue” 关键字时发出 continue 当在 finally 子句中找到 ，这 是语法错误。
抽象类实例化（E0110） ：

    具有实例化抽象方法的抽象类 %r 作为元类的抽象类 当以abc.ABCMeta 具有抽象 时使用 方法并被实例化。
star-needs-assignment-target (E0114) :

    只能在赋值目标中使用星号表达式 当赋值目标中未使用星号表达式时发出。
重复参数名称 (E0108) ：

    函数定义中的参数名称 %s 重复 函数定义中的重复参数名称是语法错误。
返回初始化（E0101） ：

    在 __init__ 中显式返回 当特殊类方法 __init__ 具有显式返回值时使用。
太多星号表达式 (E0112) ：

    作业中有多个加星标的表达式 当一个表达式中有多个加星标的表达式 ( *x ) 时发出 任务。 这是一个语法错误。
非局部和全局（E0115） ：

    名称 %r 是非本地的和全局的 当名称既是非本地名称又是全局名称时发出。
使用过的全局声明（E0118） ：

    名称 %r 在全局声明之前使用 在全局声明之前使用名称时发出，这会导致 自 Python 3.6 以来的错误。 使用 Python < 时无法发出此消息 3.6.
函数外返回 (E0104) :

    返回外部函数 当在函数或方法之外发现“return”语句时使用。
生成器返回参数 (E0106) ：

    在生成器中返回参数 当带有参数的“return”语句出现在 生成器函数或方法（例如带有一些“yield”语句）。 这 使用 Python >= 3.3 时无法发出消息。
无效的星级分配目标 (E0113) ：

    加星号的分配目标必须在列表或元组中 当星号表达式用作星号分配目标时发出。
错误的逆序 (E0111) ：

    第一个 reversed() 参数不是序列 当 reversed() 内置函数的第一个参数不是序列时使用（不 实现 __reversed__，也不是 __getitem__ 和 __len__
不存在的运营商 (E0107) ：

    使用了不存在的 %s 运算符 当您尝试使用 C 风格的预递增或预递减时使用 运算符 -- 和 ++，它们在 Python 中不存在。
yield-outside-function (E0105) ：

    产量外部功能 当在函数或方法之外发现“yield”语句时使用。
初始化是生成器（E0100） ：

    __init__ 方法是一个生成器 当特殊的类方法 __init__ 被一个生成器变成一个生成器时使用 在它的身体里产生。
格式功能错位 (E0119) ：

    str 上未调用格式函数 未在 str 对象上调用格式函数时发出。 例如做 print("value: {}").format(123) 而不是 print("value: {}".format(123))。 这可能不是用户想要做的。
非本地无绑定 (E0117) ：

    发现未绑定的非本地名称 %s 当非局部变量在某处没有附加名称时发出 父范围
丢失异常（W0150） ：

    finally 块中的 %s 语句可能会吞下异常 当在 finally 子句中发现 break 或 return 语句时使用 try...finally 块：try 子句中引发的异常将是 默默地吞了下去，而不是被重新举起。
元组断言（W0199） ：

    对填充的元组调用断言。 您指的是 'assert x,y' 吗？ 如果元组不是 为空，如果为空，则始终计算为 false。
断言字符串文字 (W0129) ：

    断言语句将字符串文字作为其第一个参数。 断言将 %s 失败。 当 assert 语句将字符串文字作为其第一个参数时使用， 这将导致断言始终通过。
自赋值变量（W0127） ：

    将同一个变量 %r 赋值给自身 当我们检测到一个变量被分配给它自己时发出
与可调用的比较（W0143） ：

    与可调用对象相比，您是否省略了括号？ 当 pylint 检测到与可调用对象的比较时，会发出此消息 做了，这可能表明省略了一些括号，结果 在潜在的不良行为中。
比较（W0177） ：

    比较 %s 应该是 %s 当表达式与 NaN 值（如 numpy.NaN 和 浮动（'南'）。
危险默认值 (W0102) ：

    作为参数的危险默认值 %s 在默认值中检测到可变值作为列表或字典时使用 参数的值。
重复键（W0109） ：

    字典中的重复键 %r 当字典表达式多次绑定同一个键时使用。
重复值 (W0130) ：

    集中的重复值 %r 当一个集合包含两次或更多次相同的值时，会发出此消息。
无用的循环（W0120） ：

    没有 break 语句的循环上的 Else 子句，删除 else 并取消缩进其中的所有代码 循环只有在可以通过中断提前退出时才应该有一个 else 子句 语句，否则 else 下的语句应该与 循环本身。
毫无意义的异常语句 (W0133) ：

    异常语句无效 在没有分配、引发或返回的情况下创建异常时使用 供以后在别处使用。
表达式未分配 (W0106) ：

    表达式“%s”未分配任何内容 当一个不是函数调用的表达式没有赋值时使用。 可能另有打算。
混淆语句 (W0124) ：

    跟随另一个上下文管理器的“as”看起来像一个元组。 时发出 当with 语句组件返回多个值并使用 进行名称绑定 as 仅对这些值的一部分使用 ，例如使用 ctx() as 一个，乙。 这可能会产生误导，因为不清楚上下文管理器是否 返回一个元组，或者如果没有名称绑定的节点是另一个上下文 经理。
不必要的 lambda (W0108) ：

    Lambda 可能不是必需的 当 lambda 表达式的主体是对其的函数调用时使用 参数列表作为 lambda 本身； 这样的 lambda 表达式除了 很少有情况可以用在正文中调用的函数替换 拉姆达。
没有上下文的命名表达式 (W0131) ：

    在没有上下文的情况下使用命名表达式 如果命名表达式用于在 上下文，如 if、for、while 或理解。
重新声明的指定名称 (W0128) ：

    在赋值中重新声明变量 %r 当我们检测到在同一赋值中重新声明了一个变量时发出。
毫无意义的陈述（W0104） ：

    声明似乎没有效果 当语句没有（或至少似乎没有）任何效果时使用。
毫无意义的字符串语句 (W0105) ：

    字符串语句无效 当字符串用作语句时使用（当然没有效果）。 这是 W0104 的特例，它有自己的消息，因此您可以轻松地 如果您将这些字符串用作文档而不是 评论。
不必要的通过（W0107） ：

    不必要的通过声明 当遇到可以避免的“pass”语句时使用。
无法到达（W0101） ：

    无法访问的代码 当“return”或“raise”语句后面有一些代码时使用，这 永远不会被访问。
评估使用（W0123） ：

    评估的使用 当您使用“eval”函数时使用，以阻止它的使用。 考虑 使用 ast.literal_eval 安全地评估包含 Python 的字符串 来自不受信任来源的表达。
执行使用（W0122） ：

    执行的使用 使用“exec”语句时引发。 使用此功能很危险 对于用户输入，它通常也比实际代码慢。 这 并不意味着你不应该使用它，但你应该考虑替代品 首先限制可用的功能。
使用常量测试（W0125） ：

    使用具有常量值的条件语句 当条件语句（If 或三元 if）使用常量值时发出 对其进行测试。 这可能不是用户想要做的。
测试中缺少括号 (W0126) ：

    由于缺少括号而使用可能错误的函数或方法调用的条件语句 当条件语句（If 或三元 if）似乎错误地调用时发出 由于缺少括号而导致的功能
常数比较（R0133） ：

    常数之间的比较：“%s %s %s”具有常数值 当两个文字相互比较时，结果是一个常数。 直接使用常量更易于阅读且性能更高。 自 Python 2.3 以来，不再需要以这种方式初始化“True”和“False”。
文字比较（R0123） ：

    在“%s”中，比较常量文字而不是“%s”时使用“%s”（“%s”） 将对象与文字进行比较时使用，这通常是您不需要的 想做，因为你可以比较一个不同的文字 预计完全。
与自身比较（R0124） ：

    冗余比较 - %s 当某物与自身进行比较时使用。
无效名称 (C0103) ：

    %s 名称“%s”不符合 %s 当名称不符合与其类型关联的命名规则时使用 （常量、变量、类...）。
单身比较（C0121） ：

    比较 %s 应该是 %s 当表达式与单例值（如 True、False 或 没有任何。
不允许的名称 (C0104) ：

    不允许的名称“%s” 当名称匹配 bad-names 或 bad-names-rgxs-（未经授权的名称）时使用。
空文档字符串 (C0112) ：

    清空 %s 文档字符串 当模块、函数、类或方法有空文档字符串时使用（它 太容易了;)。
缺少类文档字符串 (C0115) ：

    缺少类文档字符串 当类没有文档字符串时使用。 即使是一个空类也必须有一个 文档字符串。
缺少函数文档字符串 (C0116) ：

    缺少函数或方法文档字符串 当函数或方法没有文档字符串时使用。 一些特殊的方法比如 __init__ 不需要文档字符串。
缺少模块文档字符串 (C0114) ：

    缺少模块文档字符串 当模块没有文档字符串时使用。 空模块不需要 文档字符串。
typevar-name-incorrect-variance (C0105) ：

    类型变量名称不反映差异%s 当 TypeVar 名称未反映其类型差异时发出。 根据 PEP8，建议给变量加上后缀'_co'和'_contra' 分别用于声明协变或逆变行为。 不变的 （默认）变量不需要后缀。 该消息也会在以下情况下发出 不变变量确实有一个后缀。
typevar-double-variance (C0131) ：

    TypeVar 不能既协变又逆变 当“协变”和“逆变”关键字参数都是 在 TypeVar 中设置为“True”。
类型变量名称不匹配 (C0132) ：

    TypeVar 名称“%s”与分配的变量名称“%s”不匹配 当 TypeVar 分配给与其名称不匹配的变量时发出 争论。
单一类型检查（C0123） ：

    使用 isinstance() 而不是 type() 进行类型检查。 在 Python 中执行显式类型检查的惯用方法是使用 isinstance(x, Y) 而不是 type(x) == Y，type(x) is Y。虽然有 这些给出不同结果的不寻常情况。

基本检查报告

RP0101 :

    按类型统计

类检查器

检查器的逐字名称是 classes.

另请参阅 类检查器选项的文档
类检查器消息

定义前访问成员 (E0203) ：

    在其定义行 %s 之前访问成员 %r 当实例成员在实际分配之前被访问时使用。
方法隐藏（E0202） ：

    %s 行 %s 中定义的属性隐藏了此方法 当类定义被实例属性隐藏的方法时使用 来自祖先类或由某些客户端代码设置。
分配非插槽（E0237） ：

    分配给未在类槽中定义的属性 %r 在分配给类插槽中未定义的属性时使用。
重复碱基 (E0241) ：

    类 %r 的重复碱基 在派生类中重复使用基类会引发类型错误。
无效枚举扩展 (E0244) ：

    扩展继承的枚举类“%s” 当类试图扩展继承的 Enum 类时使用。 这样做会 在运行时引发 TypeError。
不一致-mro (E0240) :

    类 %r 的方法解析顺序不一致 当类具有不一致的方法解析顺序时使用。
继承非类（E0239） ：

    继承 %r，它不是一个类。 当一个类继承自非类的东西时使用。
无效插槽 (E0238) ：

    无效的 __slots__ 对象 当在类中发现无效的 __slots__ 时使用。 只有一个字符串，一个可迭代的 或序列是允许的。
无效类对象 (E0243) ：

    对“__class__”的分配无效。 应该是类定义但得到了“%s” 在将无效对象分配给 __class__ 属性时使用。 只有一个班级 被允许。
无效插槽对象 (E0236) ：

    __slots__ 中的无效对象 %r，必须仅包含非空字符串 当 __slots__ 中出现无效（非字符串）对象时使用。
无方法参数（E0211） ：

    方法 %r 没有参数 当应将绑定实例作为第一个参数的方法具有 没有定义参数。
无自辩 (E0213) :

    方法 %r 应该将“self”作为第一个参数 当方法具有不同于“self”的属性作为第一个参数时使用。 这被认为是一个错误，因为这是一个非常普遍的约定，以至于您 不应该打破它！
意外的特殊方法签名（E0302） ：

    特殊方法 %r 需要 %s 个参数，给定 %d %s 当使用无效数量定义特殊方法时发出 参数。 如果它太少或太多，它可能根本不起作用。
类变量槽冲突（E0242） ：

    槽中的值 %r 与类变量冲突 当 __slots__ 中的值与类变量、属性或 方法。
返回无效布尔值（E0304） ：

    __bool__ 不返回 bool 当 __bool__ 方法返回非布尔值时使用
无效字节返回（E0308） ：

    __bytes__ 不返回字节 当 __bytes__ 方法返回不是字节的东西时使用
无效格式返回（E0311） ：

    __format__ 不返回 str 当 __format__ 方法返回不是字符串的内容时使用
返回无效的 getnewargs (E0312) ：

    __getnewargs__ 不返回元组 当 __getnewargs__ 方法返回不是元组的东西时使用
invalid-getnewargs-ex-returned (E0313) :

    __getnewargs_ex__ 不返回包含 (tuple, dict) 的元组 当 __getnewargs_ex__ 方法返回不属于 形成元组（元组，字典）
无效哈希返回（E0309） ：

    __hash__ 不返回 int 当 __hash__ 方法返回的不是整数时使用
无效索引返回（E0305） ：

    __index__ 不返回 int 当 __index__ 方法返回的不是整数时使用
非迭代器返回（E0301） ：

    __iter__ 返回非迭代器 当 __iter__ 方法返回不可迭代的东西时使用（即 没有 __next__ 方法）
无效长度返回（E0303） ：

    __len__ 不返回非负整数 当 __len__ 方法返回非负值时使用 整数
无效长度提示返回 (E0310) ：

    __length_hint__ 不返回非负整数 当 __length_hint__ 方法返回的东西不是非 负整数
无效的代表返回（E0306） ：

    __repr__ 不返回 str 当 __repr__ 方法返回不是字符串的内容时使用
无效的 str 返回（E0307） ：

    __str__ 不返回 str 当 __str__ 方法返回不是字符串的内容时使用
参数不同（W0221） ：

    %s %s %r 方法 当方法的参数数量与方法中的参数数量不同时使用 实现的接口或重写的方法。 额外的参数 默认值被忽略。
参数重命名 (W0237) ：

    %s %s %r 方法 当方法参数的名称与实现的名称不同时使用 接口或重写的方法。
受保护的访问（W0212） ：

    访问客户端类的受保护成员 %s 当受保护的成员（即名称以 下划线）是类外的访问或类的后代 where 它被定义了。
属性定义外部初始化 (W0201) ：

    在 __init__ 之外定义的属性 %r 在 __init__ 方法之外定义实例属性时使用。
子类最终类（W0240） ：

    %r 类是用 typing.final 修饰的类的子类：%r 当用 typing.final 装饰的类已被子类化时使用。
隐式标志别名 (W0213) ：

    标记成员 %(overlap)s 与 %(sources)s 共享位位置 当在 enum.IntFlag 类中声明的多个整数值共享时使用 一个共同的位位置。
抽象方法（W0223） ：

    方法 %r 在类 %r 中是抽象的，但在子类 %r 中没有被覆盖 当抽象方法（即 raise NotImplementedError）不是 在具体类中重写。
覆盖最终方法（W0239） ：

    方法 %r 覆盖了在类 %r 中定义的用 typing.final 修饰的方法 当覆盖了 typing.final 修饰的方法时使用。
无效覆盖方法 (W0236) ：

    方法 %r 应该是 %r，却发现它是 %r 当我们检测到一个方法以不匹配的方式被覆盖时使用 它的基类可能会在运行时导致潜在的错误。
子类中重新定义的插槽 (W0244) ：

    在子类中重新定义插槽 %r 在子类中重新定义插槽时使用。
签名不同（W0222） ：

    签名不同于 %s %r 方法 当方法签名与实现的接口不同时使用 或者在重写的方法中。
坏的静态方法参数（W0211） ：

    以 %r 作为第一个参数的静态方法 当静态方法具有“self”或在 valid- 中指定的值时使用 classmethod-first-arg 选项或 valid-metaclass-classmethod-first-arg 选项 作为第一个参数。
超级无括号（W0245） ：

    没有括号的超级调用 当对 super 的调用没有括号时使用，因此不是实际的 调用并没有按预期工作。
未使用的私有成员（W0238） ：

    未使用的私有成员“%s.%s” 当定义了类的私有成员但未使用时发出。
无用的父委托 (W0246) ：

    方法 %r 中无用的父级或 super() 委托 每当我们可以检测到重写的方法无用时使用，依赖于 parent 或 super() 委托做与另一个方法相同的事情 MRO。
非父初始化调用（W0233） ：

    来自非直接基类 %r 的 __init__ 方法被调用 在不在直接目录中的类上调用 __init__ 方法时使用 分析类的祖先。
超级初始化未调用（W0231） ：

    未调用基类 %r 的 __init__ 方法 当祖先类方法具有未调用的 __init__ 方法时使用 通过派生类。
带参数的属性（R0206） ：

    不能为属性定义参数 当我们检测到一个属性也有参数时使用，这些参数是无用的， 鉴于不能使用其他参数调用属性。
无用对象继承（R0205） ：

    类 %r 继承自对象，可以安全地从 python3 中的基中删除 当类继承自对象时使用，在 python3 下是隐式的，因此 可以安全地从基地移除。
无类方法装饰器（R0202） ：

    考虑使用装饰器而不是调用类方法 在不使用装饰器语法定义类方法时使用。
无静态方法装饰器（R0203） ：

    考虑使用装饰器而不是调用静态方法 在不使用装饰器语法定义静态方法时使用。
单字符串用于插槽 (C0205) ：

    类 __slots__ 应该是一个非字符串可迭代对象 当类 __slots__ 是一个简单的字符串而不是可迭代对象时使用。
错误的类方法参数 (C0202) ：

    Class method %s should have %s as first argument Used when a class method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to "cls"), recommended to easily differentiate them from regular instance methods.
bad-mcs-classmethod-argument (C0204):

    Metaclass class method %s should have %s as first argument Used when a metaclass class method has a first argument named differently than the value specified in valid-metaclass-classmethod-first-arg option (default to "mcs"), recommended to easily differentiate them from regular instance methods.
bad-mcs-method-argument (C0203):

    Metaclass method %s should have %s as first argument Used when a metaclass method has a first argument named differently than the value specified in valid-classmethod-first-arg option (default to "cls"), recommended to easily differentiate them from regular instance methods.
method-check-failed (F0202):

    Unable to check methods signature (%s / %s) Used when Pylint has been unable to check methods signature compatibility for an unexpected reason. Please report this kind if you don't make sense of it.

Design checker

Verbatim name of the checker is design.

See also design checker's options' documentation
Design checker Messages

too-few-public-methods (R0903):

    Too few public methods (%s/%s) Used when class has too few public methods, so be sure it's really worth it.
太多的祖先（R0901） ：

    祖先太多（%s/%s） 当类有太多父类时使用，尝试减少它以获得 更简单（也更容易使用）的类。
参数太多（R0913） ：

    参数太多（%s/%s） 当函数或方法接受太多参数时使用。
太多布尔表达式 (R0916) ：

    if 语句中的布尔表达式过多 (%s/%s) 当 if 语句包含太多布尔表达式时使用。
分支太多（R0912） ：

    分支太多（%s/%s） 当函数或方法有太多分支时使用，使其难以执行 跟随。
太多实例属性（R0902） ：

    实例属性太多（%s/%s） 当类具有太多实例属性时使用，尝试减少它以获得 更简单（也更容易使用）的类。
太多当地人（R0914） ：

    局部变量太多（%s/%s） 当函数或方法有太多局部变量时使用。
太多公共方法（R0904） ：

    公共方法太多（%s/%s） 当类有太多公共方法时使用，尝试减少它以获得 更简单（也更容易使用）的类。
返回语句过多 (R0911) ：

    返回语句太多（%s/%s） 当一个函数或方法有太多的返回语句时使用，使它变得困难 跟随。
太多的陈述（R0915） ：

    语句过多（%s/%s） 当函数或方法有太多语句时使用。 然后你应该分裂 它在较小的功能/方法中。

异常检查器

检查器的逐字名称是 exceptions.

另请参阅 异常检查器选项的文档
异常检查器消息

坏订单除外（E0701） ：

    错误的 except 子句顺序 (%s) 当 except 子句的顺序不正确时使用（来自更具体的 更通用）。 如果您不固定订单，则可能不会出现某些例外情况 被最具体的处理程序捕获。
捕获非异常（E0712） ：

    捕获不从异常继承的异常：%s 当一个不继承自 Exception 的类被用作 except 子句中的异常。
坏异常原因（E0705） ：

    异常原因设置为不是异常的东西，也不是无 在使用语法“raise ... from ...”时使用，其中异常原因是 没有例外，也没有。
notimplemented-raised (E0711) :

    NotImplemented 引发 - 应该引发 NotImplementedError 在引发 NotImplemented 而不是 NotImplementedError 时使用
提高不良类型（E0702） ：

    在只允许类或实例的情况下引发 %s 当引发既不是类也不是实例的东西时使用（即 TypeError ） 。 将引发
引发非异常（E0710） ：

    提出一个不继承自 BaseException 的新样式类 当不从 BaseException 继承的新样式类是 上调。
错位裸加注 (E0704) ：

    raise 语句不在 except 子句中 在 except 子句中未使用 bare raise 时使用。 这会产生一个 错误，因为没有要重新引发的活动异常。 一个例外 该规则由 finally 子句中的裸加注表示，这可能 工作，只要在 try 块内引发异常，但它是 尽管如此，代码味道不应该被依赖。
重复 - 除了（W0705） ：

    捕获以前捕获的异常类型 %s 当 except 捕捉到一个已经被前一个捕捉到的类型时使用 处理程序。
广泛异常捕获（W0718） ：

    捕获过于一般的异常 %s 如果你使用裸机 except Exception:子句，你可能最终会抓住 除了您希望捕获的异常之外的异常。 这可以隐藏错误或 当不相关的错误被隐藏时，调试程序变得更加困难。
引发缺失（W0707） ：

    考虑使用来自 %s 的 %s'%s 明确地重新加注 Python 的异常链显示了当前异常的回溯，但是 也是原来的例外。 当你一个接一个地提出新的异常时 异常被捕获，很可能第二个异常是一个友好的重新 第一个异常的包装。 在这种情况下， raise from 提供了更好的 最终错误中两个回溯之间的链接。
提高格式元组 (W0715) ：

    异常参数表明字符串格式可能是有意的 将多个参数传递给异常构造函数时使用，第一个 其中一个字符串文字包含似乎是占位符的内容 用于格式化
二进制操作异常 (W0711) ：

    要捕获的异常是二进制“%s”操作的结果 当要捕获的异常的形式为“A 或 B 除外：”时使用。 如果 打算捕获多个，重写为“除了（A，B）：”
错误异常操作（W0716） ：

    异常操作无效。 %s 当针对异常完成操作时使用，但操作不是 对所讨论的异常有效。 通常在有二进制文件时发出 除了处理程序中的异常之间的操作。
裸（W0702）除外 ：

    未指定异常类型 光秃秃的 except:子句会抓住 SystemExit和 KeyboardInterrupt 异常，使中断程序变得更加困难 Control-C， 和 可以掩盖其他问题。 如果你想捕获所有发出信号的异常 程序错误，使用 except Exception:（除了相当于 except BaseException:).
引发广泛异常 (W0719) ：

    引发过于普遍的异常：%s 引发过于通用的异常会迫使您捕获异常 也一般。 它会迫使你使用裸体 except Exception:条款。 然后，您可能最终会捕捉到异常，而不是您 期待赶上。 这可以隐藏错误或在以下情况下更难调试程序 隐藏不相关的错误。
尝试除了提高（W0706） ：

    except 处理程序立即引发 当 except 处理程序使用 raise 作为其第一个或唯一的运算符时使用。 这是 没用，因为它会立即引发异常。 移除加注 运算符或整个 try-except-raise 块！

格式检查器

检查器的逐字名称是 format.

另请参阅 格式检查器选项的文档
格式检查器消息

错误缩进（W0311） ：

    错误的缩进。 已找到 %s %s，应为 %s 当出现意外数量的缩进制表或空格时使用 被发现。
不必要的分号（W0301） ：

    不必要的分号 当语句以分号（“;”）结束时使用，这不是必需的 （那是 python，不是 C；）。
缺少最终换行符 (C0304) ：

    缺少最后的换行符 当文件中的最后一行缺少换行符时使用。
线路太长 (C0301) ：

    行太长（%s/%s） 当一行长于给定的字符数时使用。
混合行结尾 (C0327) ：

    混合行结尾 LF 和 CRLF 当文件中有混合的（LF 和 CRLF）换行符时使用。
多语句 (C0321) ：

    一行中有多个语句 当在同一行上发现多个语句时使用。
行数过多 (C0302) ：

    模块中的行太多（%s/%s） 当模块行数过多时使用，会降低其可读性。
尾随换行符（C0305） ：

    尾随换行符 当文件中有尾随空行时使用。
尾随空格 (C0303) ：

    尾随空格 当行尾和换行符之间有空格时使用。
意外行结束格式 (C0328) ：

    意外的行结束格式。 有“%s”，但它应该是“%s”。 当换行符与预期不同时使用。
多余的父母（C0325） ：

    %r 关键字后不必要的括号 当括号中的单个项目跟在 if、for 或其他关键字之后时使用。

进口检查员

检查器的逐字名称是 imports.

另请参阅 导入检查器选项的文档
导入检查器消息

相对超顶层 (E0402) ：

    尝试相对导入超出顶级包 当相对导入试图访问当前层中过多的层级时使用 包裹。
导入错误（E0401） ：

    无法导入 %s 当 pylint 无法导入模块时使用。
弃用模块（W4901） ：

    弃用的模块 %r 标记为已弃用的模块已导入。
进口自我（W0406） ：

    模块导入自身 在模块导入自身时使用。
首选模块 (W0407) ：

    更喜欢导入 %r 而不是 %r 当导入的模块具有首选替换模块时使用。
重新进口 (W0404) ：

    重新导入 %r（导入行 %s） 当多次导入模块时使用。
阴影导入（W0416） ：

    阴影 %r（导入行 %s） 当一个模块的别名与一个隐藏另一个导入的名称时使用。
通配符导入（W0401） ：

    通配符导入 %s 时使用。 from module import * 当检测到
错位的未来（W0410） ：

    __future__ import 不是第一个非文档字符串语句 Python 2.5 及更高版本要求 __future__ import 成为第一个非 模块中的文档字符串语句。
循环导入（R0401） ：

    循环导入（%s） 当检测到两个或多个模块之间的循环导入时使用。
考虑使用来自进口 (R0402) ：

    请改用“来自 %s 导入 %s” 当导入包的子模块并使用相同的别名时发出 名称，例如，而不是 import concurrent.futures as futures使用 from concurrent import futures.
进口订单错误 (C0411) ：

    %s 应该放在 %s 之前 当不遵守 PEP8 导入顺序时使用（首先是标准导入，然后是 第三方库，然后本地导入）。
导入位置错误 (C0413) ：

    导入“%s”应该放在模块的顶部 当代码和导入混合时使用。
无用的导入别名 (C0414) ：

    导入别名不会重命名原始包 当导入别名与原始包相同时使用，例如，使用 import numpy as numpy 而不是 import numpy as np.
导入外部顶层 (C0415) ：

    导入外部顶层（%s） 当 import 语句用于模块以外的任何地方时使用 顶层。 将此导入移动到文件的顶部。
未分组的进口 (C0412) ：

    从包 %s 导入的内容未分组 当导入未按包分组时使用。
多次进口 (C0410) ：

    一行中的多个导入 (%s) 当检测到导入多个模块的导入语句时使用。

导入检查报告

RP0401 :

    外部依赖
RP0402 :

    模块依赖关系图

Lambda-表达式检查器

检查器的逐字名称是 lambda-expressions.
Lambda 表达式检查器消息

不必要的 lambda 赋值 (C3001) ：

    分配给变量的 Lambda 表达式。 改为使用“def”关键字定义一个函数。 在将 lambda 表达式分配给变量而不是定义一个变量时使用 带有“def”关键字的标准函数。
不必要的直接 lambda 调用 (C3002) ：

    直接调用 Lambda 表达式。 相反，执行内联表达式。 在直接调用 lambda 表达式而不是执行其表达式时使用 内联内容。

日志检查器

检查器的逐字名称是 logging.

另请参阅 记录检查器选项的文档
记录检查器消息

日志格式截断 (E1201) ：

    记录格式字符串在转换说明符的中间结束 当日志语句格式字符串在一个语句结束之前终止时使用 转换说明符。
日志记录太少参数（E1206） ：

    没有足够的参数用于记录格式字符串 当日志格式字符串的参数太少时使用。
日志记录太多参数（E1205） ：

    日志格式字符串的参数太多 当为日志记录格式字符串提供太多参数时使用。
日志记录格式不受支持 (E1200) ：

    索引 %d 处不支持的日志记录格式字符 %r (%#02x) 在日志语句中使用不支持的格式字符时使用 格式化字符串。
日志格式插值（W1202） ：

    在记录函数中使用 %s 格式 当日志语句的调用形式为“logging.<logging”时使用 method>(format_string.format(format_args...))"。使用另一种类型的字符串 格式代替。 您可以使用 % 格式，但将插值留给 通过将参数作为参数传递来记录函数。 如果记录-fstring- 插值被禁用，那么你可以使用 fstring 格式。 如果记录- not-lazy 被禁用，那么你可以像往常一样使用 % 格式。
日志记录 fstring 插值 (W1203) ：

    在记录函数中使用 %s 格式 当日志语句的调用形式为“logging.<logging”时使用 方法>(f"...")"。使用另一种类型的字符串格式代替。您可以使用 % 格式化但通过传递将插值留给日志记录功能 参数作为参数。 如果日志格式插值被禁用，那么你 可以使用 str.format。 如果 logging-not-lazy 被禁用，那么你可以使用 % 格式化正常。
日志记录不懒惰（W1201） ：

    在记录函数中使用 %s 格式 当日志语句的调用形式为“logging.<logging”时使用 method>(format_string % (format_args...))"。使用另一种类型的字符串 格式代替。 您可以使用 % 格式，但将插值留给 通过将参数作为参数传递来记录函数。 如果记录-fstring- 插值被禁用，那么你可以使用 fstring 格式。 如果记录- 禁用格式插值，然后您可以使用 str.format。

方法参数检查器

检查器的逐字名称是 method_args.

另请参阅 method_args 检查器选项的文档
方法参数检查器消息

仅位置参数预期 (E3102) ：

    `%s()` 获得了一些作为关键字参数传递的位置参数：%s 当仅位置参数作为关键字参数传递时发出。 删除函数调用中受影响参数的关键字。 这 使用 Python < 3.8 时无法发出消息。
缺少超时（W3101） ：

    缺少方法“%s”的超时参数会导致您的程序无限期挂起 当方法需要“超时”参数以避免等待时使用 很长时间。 如果没有明确指定超时，则使用默认值。 例如，对于“请求”，程序永远不会超时（即挂起 无限期）。

指标检查器

检查器的逐字名称是 metrics.
指标检查器报告

RP0701 :

    原始指标

杂项检查器

检查器的逐字名称是 miscellaneous.

另请参阅 杂项检查器选项的文档
杂项检查消息

固定我（W0511） ：

    当检测到 FIXME 或 XXX 警告提示时使用。
使用符号消息代替 (I0023) ：

    当通过 id 启用或禁用消息时使用。

修改迭代检查器

检查器的逐字名称是 modified_iteration.
修改后的迭代检查器消息

修改后的迭代字典（E4702） ：

    迭代字典“%s”正在 for 循环体内修改，而是迭代它的一个副本。 当向正在迭代的字典中添加或删除项目时发出。 这样做会引发 RuntimeError。
修改迭代集（E4703） ：

    迭代集“%s”正在 for 循环体内修改，而是迭代它的副本。 当项目被添加或删除到正在迭代的集合中时发出。 这样做会引发 RuntimeError。
修改迭代列表（W4701） ：

    迭代列表“%s”正在 for 循环体内修改，请考虑迭代它的副本。 当项目被添加或删除到正在迭代的列表中时发出。 这样做会导致意想不到的行为，这就是为什么首选 使用列表的副本。

嵌套最小最大检查器

检查器的逐字名称是 nested_min_max.
嵌套的最小最大检查器消息

嵌套最小最大（W3301） ：

    不要使用“%s”的嵌套调用； 可以改为“%s” 嵌套调用 min(1, min(2, 3))可以改写为 min(1, 2, 3).

新样式检查器

检查器的逐字名称是 newstyle.
Newstyle 检查器消息

坏超级呼叫（E1003） ：

    错误的第一个参数 %r 给 super() 当当前类的另一个参数作为第一个参数给出时使用 超级内置的。

Nonascii-Checker 检查器

检查器的逐字名称是 nonascii-checker.
Nonascii-Checker 检查消息

非 ascii 文件名 (W2402) ：

    %s 名称“%s”包含非 ASCII 字符。 在 python 3.5 下，PEP 3131 允许使用非 ascii 标识符，但不允许非 ascii 文件名。从 Python 3.5 开始，即使 Python 支持 UTF-8 文件，一些 编辑器或工具没有。
非 ascii 名称 (C2401) ：

    %s 名称“%s”包含非 ASCII 字符，请考虑重命名它。 当名称包含至少一个非 ASCII unicode 字符时使用。 看 https://peps.python.org/pep-0672/#confusing-features 了解背景原因 这可能很糟糕。 如果您的编程指南定义您是 用英文编程，那么应该不需要非ASCII字符 在 Python 名称中。 如果不是，您可以简单地禁用此检查。
非 ascii 模块导入 (C2403) ：

    %s 名称“%s”包含非 ASCII 字符，请使用仅 ASCII 的别名进行导入。 当名称包含至少一个非 ASCII unicode 字符时使用。 看 https://peps.python.org/pep-0672/#confusing-features 了解背景原因 这可能很糟糕。 如果您的编程指南定义您是 用英文编程，那么应该不需要非ASCII字符 在 Python 名称中。 如果不是，您可以简单地禁用此检查。

重构检查器

检查器的逐字名称是 refactoring.

另请参阅 重构检查器选项的文档
重构检查器消息

简化条件（R1726） ：

    布尔条件“%s”可以简化为“%s” 当能够简化布尔条件时发出。
condition-evals-to-constant (R1727) ：

    布尔条件“%s”将始终计算为“%s” 当布尔条件可以简化为常量值时发出。
简化布尔表达式 (R1709) ：

    布尔表达式可以简化为 %s 当使用冗余的 pre-python 2.5 三元语法时发出。
考虑使用 (R1714) ：

    考虑使用“%s %sin (%s)”将这些比较与“in”合并。 如果元素是可散列的，请改用集合。 要检查变量是否等于多个值之一，请组合这些值 进入一个集合或元组并检查变量是否包含在它的“中”而不是 检查每个值是否相等。 这样更快，更少 冗长。
考虑合并实例（R1701） ：

    考虑将这些 isinstance 调用合并到 isinstance(%s, (%s)) 当多个连续的 isinstance 调用可以合并为一个时使用。
使用字典文字 (R1735) ：

    考虑使用“%s”而不是调用“dict”。 使用 dict() 创建字典而不是文字 '{ ... }'。 文字更快，因为它避免了额外的函数调用。
考虑使用最大内置 (R1731) ：

    考虑使用“%s”而不是不必要的 if 块 使用 max 内置函数而不是条件函数可以提高可读性和 简明。
考虑使用最小内置 (R1730) ：

    考虑使用“%s”而不是不必要的 if 块 使用 min 内置而不是条件提高可读性和 简明。
考虑使用系统退出（R1722） ：

    考虑改用“sys.exit” 与 'exit()' 或 'quit()' 相反，'sys.exit' 不依赖于站点模块 可用（因为“sys”模块始终可用）。
考虑与 (R1732) 一起使用 ：

    考虑使用“with”进行资源分配操作 如果资源分配分配或调用可能被替换 '与'块。 通过使用“with”释放分配的资源 即使在异常情况下也能确保。
超级参数（R1725） ：

    考虑使用不带参数的 Python 3 风格的 super() 在使用当前类和实例调用 super() 内置函数时发出。 在 Python 3 上，这些参数是默认参数，可以省略。
使用列表文字 (R1734) ：

    考虑使用 [] 而不是 list() 当使用 list() 而不是文字 [] 创建一个空列表时发出。 文字更快，因为它避免了额外的函数调用。
考虑使用字典理解（R1717） ：

    考虑使用字典理解 当我们使用 dict() 可调用检测到字典的创建时发出 和一个临时列表。 虽然这在语法上没有任何错误 代码，很难阅读，可以简化为听写理解。 还 它更快，因为您不需要创建另一个临时列表
考虑使用发电机（R1728） ：

    考虑使用生成器代替“%s(%s)” 如果你的容器很大，使用发电机会带来更好的效果 表现。
考虑使用集合理解（R1718） ：

    考虑使用集合理解 虽然这段代码在语法上没有任何错误，但很难 阅读并可以简化为一组理解。 它也更快，因为 您不需要创建另一个临时列表
考虑使用 get (R1715) ：

    如果键存在，考虑使用 dict.get 从字典中获取值，如果不存在则使用默认值 如果键是，则使用内置的 dict.get 从字典中获取值 present 或 default if not，更简单并且被认为更惯用， 虽然有时会慢一点
考虑使用连接 (R1713) ：

    考虑使用 str.join(sequence) 连接来自可迭代对象的字符串 使用 str.join(sequence) 更快，使用更少的内存并增加 与 for 循环迭代相比的可读性。
考虑使用三元 (R1706) ：

    考虑使用三元（%s） 当使用已知的 pre-python 2.5 三元语法之一时使用。
考虑交换变量（R1712） ：

    考虑使用元组拆包来交换变量 您不必使用临时变量来交换变量。 使用 “元组解包”直接交换变量使意图更加明确。
尾随逗号元组（R1707） ：

    不允许尾随逗号元组 在 Python 中，元组实际上是由逗号创建的，而不是由 括号。 不幸的是，实际上可以通过错放一个元组来创建一个元组 尾随逗号，这可能会导致代码中出现潜在的奇怪错误。 你 应该始终显式地使用括号来创建元组。
停止迭代返回（R1708） ：

    不要在生成器中引发 StopIteration，而是使用 return 语句 根据 PEP479，引发 StopIteration 以结束 a 的循环 生成器可能会导致难以发现错误。 此 PEP 指定加薪 StopIteration 必须用简单的 return 语句代替
不一致的返回语句 (R1710) ：

    函数中的所有 return 语句要么都应该返回一个表达式，要么都不应该。 根据 PEP8，如果任何 return 语句返回一个表达式，任何 return 没有返回值的语句应该明确声明这是返回 无，并且显式的 return 语句应该出现在 功能（如果可达）
从本地重新定义参数 (R1704) ：

    正在使用本地名称 %r 重新定义参数 当本地名称重新定义参数时使用，这可能暗示 潜在的错误。 这仅考虑到少数名称绑定 带有语句赋值和异常的操作，例如迭代 处理程序分配。
链式比较（R1716） ：

    简化操作数之间的链式比较 当 pylint 遇到诸如 "a < b 之类的布尔运算时，会发出此消息 和 b < c"，建议改为将其重构为 "a < b < c"
可简化的 if 表达式 (R1719) ：

    if 表达式可以用 %s 代替 当 if 表达式可以用 'bool(test)' 或简单的 'test' 替换时使用 如果布尔转换是隐式的。
可简化的 if 语句 (R1703) ：

    if 语句可以用 %s 代替 当 if 语句可以用“bool(test)”替换时使用。
太多嵌套块（R1702） ：

    嵌套块太多（%s/%s） 当函数或方法有太多嵌套块时使用。 这使得 代码不易理解和维护。
没有其他中断（R1723） ：

    “break”后不必要的“%s”，%s 用于突出显示 if 后不必要的代码块 包含一个 break 语句。 因此，当它遇到一个 else 跟随一串 if，它们都包含一个 break 语句。
不要继续（R1724） ：

    “继续”后不必要的“%s”，%s 用于突出显示 if 后不必要的代码块 包含一个 continue 语句。 因此，当它遇到一个 else 跟在 if 链之后，所有 if 都包含一个 continue 语句。
不加注（R1720） ：

    “raise”后不必要的“%s”，%s 用于突出显示 if 后不必要的代码块 包含 raise 语句。 因此，当它遇到一个 else 跟在 if 链之后，所有 if 都包含一个 raise 语句。
不返回（R1705） ：

    “return”后不必要的“%s”，%s 用于突出显示 if 后不必要的代码块 包含返回语句。 因此，当它遇到一个 else 跟在一连串的 if 之后，所有 if 都包含一个 return 语句。
不必要的字典索引查找（R1733） ：

    不必要的字典索引查找，请改用“%s” 在遍历字典项（键项对）和 通过索引查找访问值。 该值可以直接访问 反而。
不必要的列表索引查找（R1736） ：

    不必要的列表索引查找，请改用“%s” 在遍历枚举并按索引访问值时发出 抬头。 可以直接访问该值。
不必要的理解（R1721） ：

    不必要地使用理解，请改用 %s。 考虑使用列表、字典或 设置构造函数。 它更快更简单。
使用发电机（R1729） ：

    使用生成器代替“%s(%s)” 不需要理解“any”、“all”、“max”、“min”或“sum”。 A 发电机就足够了，而且速度更快。
无用返回（R1711） ：

    函数或方法末尾的无用返回 当最后发现单个“return”或“return None”语句时发出 函数或方法定义。 可以安全地删除此语句 因为 Python 会隐式返回 None
使用隐式布尔值不比较 (C1803) ：

    “%s”可以简化为“%s”，因为空的 %s 是错误的 当 Pylint 检测到正在使用集合文字比较时使用 检查是否为空； 使用隐式布尔值而不是集合类； 空集合被认为是错误的
不需要（C0113） ：

    考虑将“%s”更改为“%s” 当布尔表达式包含不需要的否定时使用。
考虑迭代字典（C0201） ：

    考虑直接迭代字典而不是调用 .keys() 当字典的键通过 .keys() 方法或时间 .keys()用于成员检查。 这足以 遍历字典本身， for key in dictionary. 为了 会员资格检查， if key in dictionary是比较快的。
考虑使用字典项 (C0206) ：

    考虑使用 .items() 进行迭代 在遍历字典的键并访问值时发出 通过索引查找。 键和值都可以通过迭代访问 字典的 .items() 方法代替。
考虑使用枚举 (C0200) ：

    考虑使用 enumerate 而不是使用 range 和 len 进行迭代 当遇到使用 range 和 len 迭代的代码时发出。 这样的代码 可以通过使用 enumerate 内置函数来简化。
使用隐式布尔值非长度 (C1802) ：

    不要在没有比较的情况下使用 len(SEQUENCE) 来确定序列是否为空 当 Pylint 检测到没有显式使用 len(sequence) 时使用 在条件内进行比较以确定序列是否为空。 代替 将长度强制为布尔值，要么依赖于空的事实 序列为假或将长度与标量进行比较。
考虑使用 f 字符串 (C0209) ：

    格式化可能是 f 字符串的常规字符串 当我们检测到正在使用 format() 或 % which 格式化的字符串时使用 可能是 F 弦。 首选使用 f 弦。 要求 Python 3.6 和 py-version >= 3.6.
使用-maxsplit-arg (C0207) ：

    改用 %s 仅访问 str.split() 的第一个或最后一个元素时发出。 这 可以使用 str.split(sep, maxsplit=1)[0] 访问第一个和最后一个元素 或 str.rsplit(sep, maxsplit=1)[-1] 代替。
使用序列进行迭代（C0208） ：

    迭代值时使用序列类型 迭代值时，序列类型（例如， lists, tuples, ranges) 比 sets.

相似性检查器

检查器的逐字名称是 similarities.

另请参阅 相似性检查器选项的文档
相似性检查器消息

重复代码 (R0801) ：

    %s 文件中的相似行 表示在多个文件中检测到一组相似的行。 这通常意味着应该重构代码以避免这种情况 复制。

相似性检查报告

RP0801 :

    复制

拼写检查器

检查器的逐字名称是 spelling.

另请参阅 拼写检查器选项的文档
拼写检查器消息

文档字符串中的无效字符 (C0403) ：

    文档字符串中的无效字符 %r 当 docstring 中的单词无法被附魔检查时使用。
评论中的拼写错误 (C0401) ：

    评论中单词“%s”的拼写错误： 当评论中的单词拼写不正确时使用。
文档字符串中的拼写错误 (C0402) ：

    文档字符串中单词“%s”的拼写错误： 当文档字符串中的单词拼写不正确时使用。

标准库检查器

检查器的逐字名称是 stdlib.
标准库检查器消息

无效环境变量值 (E1507) ：

    %s 不支持 %s 类型参数 环境操作函数仅支持字符串类型参数。 看 https://docs.python.org/3/library/os.html#os.getenv 。
singledispatch 方法（E1519） ：

    singledispatch 装饰器不应与方法一起使用，而应使用 singledispatchmethod。 singledispatch 应该修饰函数而不是类/实例方法。 使用 这些情况的单一调度方法。
singledispatchmethod-function (E1520) :

    singledispatchmethod 装饰器不应与函数一起使用，而应使用 singledispatch。 singledispatchmethod 应该修饰类/实例方法而不是 功能。 在这些情况下使用 singledispatch。
不良开放模式（W1501） ：

    “%s”不是有效的打开模式。 Python 支持：r、w、a[、x] 模式，带有 b、+ 和 U（仅带有 r）选项。 请参阅 https://docs.python.org/3/library/functions.html#open
无效环境变量默认值（W1508） ：

    %s 默认类型是 %s。 预期 str 或无。 Env 操作函数返回 None 或 str 值。 提供任何东西 与默认值不同可能会导致错误。 看 https://docs.python.org/3/library/os.html#os.getenv 。
方法缓存最大大小无 (W1518) ：

    'lru_cache(maxsize=None)' 或 'cache' 将无限期地保留所有方法参数，包括 'self' 通过用 lru_cache 装饰方法或缓存 'self' 参数将是 链接到函数，因此永远不会被垃圾收集。 除非你的 实例将永远不需要被垃圾收集（单例）它是 建议重构代码以避免这种模式或将 maxsize 添加到 缓存。 maxsize 的默认值为 128。
子进程运行检查（W1510） ：

    使用“subprocess.run”时未明确定义“check”的值。 这 check关键字默认设置为 False。 是过程的意思 发起人 subprocess.run可以以非零退出代码退出并失败 默默。 最好明确设置它以明确错误是什么 - 处理行为是。
被遗忘的调试语句 (W1515) ：

    不建议在生产代码中保留创建断点的函数 对 breakpoint()、sys.breakpointhook() 和 pdb.set_trace() 的调用应该是 从未主动调试的代码中删除。
冗余单元测试断言（W1503） ：

    冗余使用 %s 和常量值 %r assertTrue 和 assertFalse 的第一个参数是一个条件。 如果一个 常量作为参数传递，该条件将始终为真。 在这个 情况下应发出警告。
浅拷贝环境（W1507） ：

    使用 copy.copy(os.environ)。 请改用 os.environ.copy() 。 os.environ 不是 dict 对象而是代理对象，所以浅拷贝仍然 对原始对象的影响。 参阅 https://bugs.python.org/issue15373 请 参考。
布尔日期时间（W1502） ：

    在布尔上下文中使用 datetime.time。 在布尔上下文中使用 datetime.time 可以在时间时隐藏细微的错误 它们代表 UTC 午夜的比赛。 此行为已在 Python 3.5 中修复。 请参阅 https://bugs.python.org/issue13936 以供参考。 这个消息不能 使用 Python >= 3.5 时发出。
弃用参数 (W4903) ：

    使用方法 %s() 的弃用参数 %s 该参数被标记为已弃用，将来会被删除。
弃用类 (W4904) ：

    使用模块 %s 的弃用类 %s 该类被标记为已弃用，将来会被删除。
弃用装饰器 (W4905) ：

    使用已弃用的装饰器 %s() 装饰器被标记为已弃用，将来会被删除。
弃用方法 (W4902) ：

    使用已弃用的方法 %s() 该方法被标记为已弃用，将来会被删除。
未指定编码 (W1514) ：

    在不显式指定编码的情况下使用 open 打开文档时最好指定一种编码。 使用系统 default implicitly 会在其他操作系统上产生问题。 看 https://peps.python.org/pep-0597/
子进程-popen-preexec-fn (W1509) ：

    使用在线程存在时可能不安全的 preexec_fn 关键字 在存在线程的情况下使用 preexec_fn 参数是不安全的 你的申请。 在调用 exec 之前，子进程可能会死锁。 如果 你必须使用它，让它变得微不足道！ 尽量减少调用的库数量 进入。 请参阅 https://docs.python.org/3/library/subprocess.html#popen-constructor
坏线程实例化（W1506） ：

    threading.Thread 需要目标函数 当没有实例化 threading.Thread 类时发出警告 目标函数作为 kwarg 或第二个参数传递。 经过 默认情况下，第一个参数是组参数，而不是目标参数。

字符串检查器

检查器的逐字名称是 string.

另请参阅 字符串检查器的选项文档
字符串检查消息

错误的字符串格式类型 (E1307) ：

    参数 %r 与格式类型 %r 不匹配 当格式字符串要求的类型不适合实际时使用 参数类型
格式需要映射 (E1303) ：

    格式字符串的预期映射，而不是 %s 当使用命名转换说明符的格式字符串与 一个不是映射的参数。
截断格式字符串 (E1301) ：

    格式字符串在转换说明符的中间结束 当格式字符串在转换结束前终止时使用 说明符。
缺少格式字符串键 (E1304) ：

    格式字符串字典中缺少键 %r 当使用命名转换说明符的格式字符串与 不包含格式字符串所需的所有键的字典。
混合格式字符串 (E1302) ：

    在格式字符串中混合命名和未命名的转换说明符 当格式字符串同时包含命名（例如'%(foo)d'）和未命名时使用 （例如“%d”）转换说明符。 这也用于命名转换 说明符包含 * 表示最小字段宽度和/或精度。
格式参数太少 (E1306) ：

    格式字符串的参数不足 当给出使用未命名转换说明符的格式字符串时使用 论据太少
坏 str-strip-call (E1310) :

    %s.%s 调用中的可疑参数 str.{l,r,}strip 调用的参数包含重复字符，
太多格式参数 (E1305) ：

    格式字符串的参数太多 当给出使用未命名转换说明符的格式字符串时使用 争论太多。
错误格式字符 (E1300) ：

    索引 %d 处的格式字符 %r (%#02x) 不受支持 在格式字符串中使用不受支持的格式字符时使用。
字符串中的异常 unicode 转义 (W1402) ：

    字节字符串中的异常 Unicode 转义：“%s”。 字符串常量可能缺少 r 或 u 前缀。 当在一个字节字符串中遇到像 u 这样的转义符时使用，而它没有 影响。
字符串中的异常反斜杠 (W1401) ：

    字符串中的异常反斜杠：“%s”。 字符串常量可能缺少 r 前缀。 当反斜杠位于文字字符串中但不作为转义符时使用。
重复字符串格式参数 (W1308) ：

    重复的字符串格式化参数 %r，考虑作为命名参数传递 当我们检测到字符串格式正在重复一个参数时使用 使用命名字符串参数
格式组合规范 (W1305) ：

    格式字符串包含自动字段编号和手动字段规范 当 PEP 3101 格式字符串同时包含自动字段编号时使用 （例如“{}”）和手动字段规范（例如“{0}”）。
格式错误的字符串密钥 (W1300) ：

    格式化字符串字典键应该是一个字符串，而不是 %s 当使用命名转换说明符的格式字符串与 键不全是字符串的字典。
隐式 str 连接 (W1404) ：

    在 %s 中发现隐式字符串连接 字符串文字在文字可迭代定义中隐式连接 : 可能少了一个逗号？
错误格式字符串 (W1302) ：

    格式字符串无效 当 PEP 3101 格式字符串无效时使用。
缺少格式属性 (W1306) ：

    格式说明符 %r 中缺少格式属性 %r 当 PEP 3101 格式字符串使用属性说明符 ({0.length}) 时使用， 但是为格式化传递的参数没有该属性。
缺少格式参数键（W1303） ：

    缺少格式字符串的关键字参数 %r 当使用命名字段的 PEP 3101 格式字符串没有收到时使用 或更多必需的关键字。
引号不一致 (W1405) ：

    引号定界符 %s 与文件的其余部分不一致 引号定界符在整个模块中的使用不一致（与 为避免不必要的转义而留出的余地）。
冗余 u 字符串前缀 (W1406) ：

    Python >=3.0 不再需要字符串的 u 前缀 当我们检测到带有 au 前缀的字符串时使用。 这些前缀是必要的 在 Python 2 中表示字符串是 Unicode，但自 Python 3.0 字符串 默认是 Unicode。
未使用的格式字符串参数 (W1304) ：

    未使用的格式参数 %r 当使用命名字段的 PEP 3101 格式字符串与 格式字符串不需要的参数。
未使用的格式字符串密钥 (W1301) ：

    格式字符串字典中未使用的键 %r 当使用命名转换说明符的格式字符串与 包含格式字符串不需要的键的字典。
f-string-without-interpolation (W1309) ：

    使用没有任何内插变量的 f 字符串 当我们检测到不使用任何插值的 f 字符串时使用 变量，在这种情况下，它可以是普通字符串，也可以是 代码。
格式字符串无插值 (W1310) ：

    对没有任何内插变量的字符串使用格式 当我们检测到一个没有任何插值变量的字符串时使用， 在这种情况下，它可以是没有格式化的普通字符串，也可以是 代码。
无效格式索引 (W1307) ：

    在格式说明符 %r 中使用无效的查找键 %r 当 PEP 3101 格式字符串使用查找说明符 ({a[1]}) 时使用，但 为格式化传递的参数不包含或没有该键作为 属性。

线程检查器

检查器的逐字名称是 threading.
线程检查器消息

无用锁（W2101） ：

    直接在“with”中创建的“%s()”无效 当使用没有的 with 语句创建新的锁实例时使用 影响。 相反，应该使用现有实例来获取锁。

类型检查器

检查器的逐字名称是 typecheck.

另请参阅 类型检查检查器的选项文档
类型检查检查器消息

不支持的赋值操作（E1137） ：

    %r 不支持项目分配 当对象不支持项目分配时发出（即不定义 __setitem__ 方法）。
不支持的删除操作 (E1138) ：

    %r 不支持项目删除 当对象不支持项目删除时发出（即不定义 __delitem__ 方法）。
无效一元操作数类型 (E1130) ：

    在不支持此操作的对象上使用一元操作数时发出 操作类型。
不支持的二进制操作 (E1131) ：

    当两个操作数之间的二进制算术运算不是 支持的。
非会员 (E1101) :

    %s %r 没有 %r 成员%s 当为不存在的成员访问变量时使用。
不可调用 (E1102) ：

    %s 不可调用 当被调用的对象被推断为不可调用对象时使用。
不可散列成员 (E1143) ：

    “%s”不可散列，不能用作 %s 中的 %s 当字典键或集合成员不可哈希时发出（即未定义 __hash__ 方法）。
等待外部异步（E1142） ：

    'await' 应该在异步函数中使用 在异步函数外使用 await 时发出。
冗余关键字参数 (E1124) ：

    在 %s 调用中按位置和关键字传递的参数 %r 当函数调用会导致将多个值分配给一个时使用 函数参数，一个值来自位置参数，一个值来自 关键字参数。
不归还分配（E1111） ：

    分配函数调用的结果，其中函数没有返回 当在函数调用上完成赋值但推断函数时使用 不返回任何东西。
无分配（E1128） ：

    分配函数调用的结果，其中函数返回 None 当在函数调用上完成赋值但推断函数时使用 除了 None 什么都不返回。
非上下文管理器（E1129） ：

    上下文管理器“%s”未实现 __enter__ 和 __exit__。 当 with 语句中的实例未实现上下文时使用 经理协议（__enter__/__exit__）。
重复关键字 (E1132) ：

    在函数调用中获得关键字参数 %r 的多个值 当函数调用获得关键字的多个值时发出。
无效元类（E1139） ：

    使用了无效的元类 %r 每当我们检测到一个类正在使用时发出，作为元类， 用作元类可能无效的东西。
失踪-kwoa (E1125) :

    在 %s 调用中缺少强制关键字参数 %r 当函数调用不传递强制性关键字参数时使用。
参数无值 (E1120) ：

    %s 调用中参数 %s 没有值 当函数调用传递的参数太少时使用。
不可迭代 (E1133) ：

    在迭代上下文中使用了不可迭代值 %s 当在需要迭代的地方使用不可迭代的值时使用
非映射 (E1134) ：

    映射上下文中使用了非映射值 %s 当在需要映射的地方使用非映射值时使用
无效序列索引 (E1126) ：

    序列索引不是具有 __index__ 的整数、切片或实例 当使用无效类型对序列类型进行索引时使用。 有效类型是 具有 __index__ 方法的整数、切片和对象。
无效切片索引 (E1127) ：

    切片索引不是 int、None 或带有 __index__ 的实例 当切片索引不是整数、None 或具有 __index__ 方法。
无效切片步骤 (E1144) ：

    切片步长不能为 0 当切片步骤为 0 且对象未实现自定义时使用 __getitem__ 方法。
函数参数太多 (E1121) ：

    %s 调用的位置参数太多 当函数调用传递太多位置参数时使用。
意外关键字参数 (E1123) ：

    %s 调用中的意外关键字参数 %r 当函数调用传递不对应的关键字参数时使用 到函数的参数名称之一。
dict-iter-missing-items (E1141) ：

    在不调用 .items() 的情况下迭代解压字典 在不调用 .items() 的情况下尝试遍历字典时发出
不受支持的成员资格测试（E1135） ：

    值“%s”不支持成员测试 当成员测试表达式中的实例未实现时发出 成员资格协议（__contains__/__iter__/__getitem__）。
不可订阅对象 (E1136) ：

    值“%s”不可订阅 当订阅值不支持订阅时发出（即不 为类定义 __getitem__ 方法或 __class_getitem__ ）。
关键字参数前可变参数 (W1113) ：

    %s 函数定义中变量位置参数列表之前的关键字参数 在可变位置参数之前定义关键字参数时，一个 最终可能会为上述参数传递多个值 如果使用关键字参数调用该方法。
非 str 赋值到 dunder 名称 (W1115) ：

    分配给 __name__ 的非字符串值 将非字符串值分配给 __name__ 时发出
参数乱序 (W1114) ：

    位置参数似乎是乱序的 当调用者的参数名称与中的参数名称完全匹配时发出 函数签名但没有相同的顺序。
isinstance-second-argument-not-valid-type (W1116) ：

    isinstance 的第二个参数不是类型 当 isinstance 调用的第二个参数不是类型时发出。
c-extension-no-member (I1101) :

    %s %r 没有 %r 成员 %s，但来源不可用。 如果你想根据活对象的运行时内省来执行分析，请考虑将此模块添加到 extension-pkg-allow-list。 当为不存在的 C 扩展成员访问变量时使用。 到期的 源静态分析的不可用性是不可能的，但它可能是 通过在运行时内省活对象来执行。

Unicode Checker 检查器

检查器的逐字名称是 unicode_checker.
Unicode 检查器检查器消息

双向统一码 (E2502) ：

    包含控制字符，允许以不同于显示的方式执行混淆代码 双向 unicode 通常不显示所需的字符 显示从右到左 (RTL) 的脚本（即中文、日语、阿拉伯语、希伯来语、 ...）正确。 那么你能相信这段代码吗？ 你确定它显示了吗 在所有编辑器中正确吗？ 如果你没有写它或者你的语言不是 RTL，删除特殊字符，因为它们可以用来诱骗您进入 执行代码，它做的不是它看起来的样子。 更多的 信息： https: //en.wikipedia.org/wiki/Bidirectional_text https://trojansource.codes/
无效字符退格 (E2510) ：

    无效的未转义字符退格键，请改用“b”。 向后移动光标，所以它后面的字符将覆盖字符 前。
无效字符回车 (E2511) ：

    无效的未转义字符回车，请改用“r”。 将光标移动到行首，后面的字符覆盖 该行的开始。
无效字符转义 (E2513) ：

    无效的未转义字符 esc，请改用“x1B”。 通常启动允许任意控制的转义码 终端。
无效字符无效 (E2514) ：

    无效的未转义字符 nul，请改用“0”。 主要是 python 的输入结束。
无效字符子 (E2512) ：

    无效的未转义字符 sub，请改用“x1A”。 Windows 上的 Ctrl+Z“文本结束”。 一些程序（如类型）忽略其余部分 它之后的文件。
无效字符零宽度空间 (E2515) ：

    无效的未转义字符零宽度空间，请改用“u200B”。 不可见的空格字符可以隐藏真正的代码执行。
无效的 unicode 编解码器 (E2501) ：

    UTF-16 和 UTF-32 不向后兼容。 改为使用 UTF-8 为了兼容性，使用 UTF-8 而不是 UTF-16/UTF-32。 也可以看看 https://bugs.python.org/issue1503789 有关此问题的历史记录。 和 https://softwareengineering.stackexchange.com/questions/102205/ 一些 例如，使用 UTF-16 时可能出现的问题。
错误文件编码 (C2503) ：

    PEP8 推荐 UTF-8 作为 Python 文件的编码 PEP8 建议对 Python 文件使用 UTF-8 默认编码。 看 https://peps.python.org/pep-0008/#source-file-encoding

Unnecessary-Dunder-Call 检查器

检查器的逐字名称是 unnecessary-dunder-call.
不必要的 Dunder-Call 检查消息

不必要的双打电话 (C2801) ：

    不必要地调用 dunder 方法 %s。 %s。 当手动调用 dunder 方法而不是使用 相应的函数/方法/运算符。

不必要的省略号检查器

检查器的逐字名称是 unnecessary_ellipsis.
不必要的省略号检查器消息

不必要的省略号（W2301） ：

    不必要的省略号常量 当遇到省略号常量并且可以避免时使用。 一行 如果上面有文档字符串，则不需要包含省略号的代码 前一行或者如果在同一范围内有一个语句。

不支持的版本检查器

检查器的逐字名称是 unsupported_version.
不支持的版本检查器消息

使用-f-string-in-unsupported-version (W2601) ：

    py-version 设置中包含的所有版本都不支持 F 字符串 当用户设置的py-version低于3.6和pylint时使用 遇到 f 弦。
在不受支持的版本 (W2602) 中使用最终装饰器 ：

    py-version 设置中包含的所有版本都不支持 typing.final 当用户设置的py-version低于3.8和pylint时使用 遇到一个 typing.final装饰器。

变量检查器

检查器的逐字名称是 variables.

另请参阅 变量检查器选项的文档
变量检查器消息

拆包非序列 (E0633) :

    正在尝试解包一个非序列 %s 当在解包分配中使用非序列的东西时使用
全格式无效 (E0605) ：

    __all__ 的格式无效，必须是元组或列表 当 __all__ 格式无效时使用。
潜在指数错误（E0643） ：

    可迭代长度的索引无效 当可迭代对象上使用的索引超出其长度时发出 可迭代的。
无效的所有对象（E0604） ：

    __all__ 中的对象 %r 无效，必须仅包含字符串 当 __all__ 中出现无效（非字符串）对象时使用。
模块中无名称 (E0611) ：

    模块 %r 中没有名称 %r 当在模块中找不到名称时使用。
未定义变量 (E0602) ：

    未定义变量 %r 在访问未定义的变量时使用。
未定义的所有变量（E0603） ：

    __all__ 中未定义的变量名 %r 当在 __all__ 中引用未定义的变量名时使用。
赋值前使用（E0601） ：

    在赋值前使用变量 %r 在分配发生之前访问局部变量时发出。 try 块中的赋值假定在评估时没有发生 关联的 except/finally 块。 假设除了块中的分配 在块外评估语句时不会发生，除了 当关联的 try 块包含 return 语句时。
cell-var-from-loop (W0640) ：

    循环中定义的单元格变量 %s 闭包中使用的变量在循环中定义。 这将导致所有 闭包对封闭变量使用相同的值。
全局变量未定义 (W0601) ：

    全局变量 %r 在模块级别未定义 当通过“全局”语句定义变量但 模块范围内未定义变量。
自 cls 分配（W0642） ：

    在方法中对 %s 的分配无效 分别在实例或类方法中对 self 或 cls 的分配无效。
不平衡字典拆包（W0644） ：

    使用 %s 解压字典可能不平衡：左侧有 %d 个标签%s，右侧有 %d 个值%s 在赋值或 for 循环中存在不平衡的 dict 解包时使用
不平衡元组拆包（W0632） ：

    序列 %s 的可能不平衡元组拆包：左侧有 %d 个标签%s，右侧有 %d 个值%s 当赋值中存在不平衡的元组拆包时使用
可能未使用的变量 (W0641) ：

    可能未使用的变量 %r 当变量已定义但可能不会被使用时使用。 可能性来了 由于可能会使用 locals() ，这可能会消耗或不消耗 所述变量
重新定义内置 (W0622) ：

    重新定义内置 %r 当变量或函数覆盖内置时使用。
重新定义外部名称 (W0621) ：

    从外部范围重新定义名称 %r（行 %s） 当变量的名称隐藏了在外部作用域中定义的名称时使用，或者除了 处理程序。
未使用的进口（W0611） ：

    未使用的 %s 在不使用导入的模块或变量时使用。
未使用的参数（W0613） ：

    未使用的参数 %r 在不使用函数或方法参数时使用。
未使用的通配符导入（W0614） ：

    %s 的通配符导入中未使用的导入 %s 当导入的模块或变量未从 “from X import” 中使用时使用 *' 样式导入。
未使用的变量（W0612） ：

    未使用的变量 %r 当变量已定义但未使用时使用。
全局变量未分配（W0602） ：

    对 %r 使用全局但没有完成赋值 当在全局范围内定义的变量在内部范围内被修改时， 仅当存在 在内部范围内完成的赋值操作。
未定义循环变量 (W0631) ：

    使用可能未定义的循环变量 %r 当循环变量（即由 for 循环或列表理解定义）时使用 或生成器表达式）在循环外使用。
全球声明（W0603） ：

    使用全局语句 当您使用“全局”语句更新全局变量时使用。 皮林特 不鼓励使用它。 这并不意味着您不能使用它！
全局模块级（W0604） ：

    在模块级别使用全局语句 当您在模块级别使用“全局”语句时使用，因为它没有 影响。

