### 三、Redis
#### 1. Redis 五大数据类型及对应使用场所。
`String`  
    1. String 是 Redis 最为常用的一种数据类型，String 的数据结构为 key/value 类型，可以用来做微博涨粉，点赞关注数变化。  
    2. 常用命令: set,get,decr,incr,mget 等。  
`Hash`  
    1. Hash 类型可以看成是一个 key/value 都是 String 的 Map 容器。 通常用来存储对象数据类型  
    2. 常用命令：hget,hset,hgetall 等。  
`List`  
    1. List 用于存储一个有序的字符串列表，常用的操作是向队列两 端添加元素或者获得列表的某一片段。可用来做微信朋友圈按时间顺序加载  
    2. 常用命令：lpush,rpush,lpop,rpop,lrange 等  
`Set`  
    1. Set 可以理解为一组无序的字符集合，Set 中相同的元素是不会重复出现的，相同的元素只保留一个。可用来做共同好友，共同关注等  
    2. 常用命令：sadd,spop,smembers,sunion 等。  
`Sorted Set（有序集合）`  
    1. 有序集合是在集合的基础上为每一个元素关联一个分数，Redis 通过分数为集合中的成员进行排序。可用来做各类排行榜应用  
    2. 常用命令：zadd,zrange,zrem,zcard 等。

#### 2. Redis 中 list 底层实现有哪几种？有什么区别？
> 列表对象的编码可以是 `ziplist` 或者 `linkedlist`
> ziplist 是一种 `压缩链表`，它的好处是更能 `节省内存空间`，因为它所存储的内容都是在连续的内存区域当中的。
> 当列表对象元素不大，每个元素也不大的时候，就采用 ziplist 存储。但当数据量过大时就 ziplist 就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是 O (N)，即每次插入都会重新进行 realloc。

#### 3. 怎样解决数据库高并发的问题？
> `解决数据库高并发的常见方案`：

1） 缓存式的 Web 应用程序架构：
    在 Web 层和 DB (数据库) 层之间加一层 cache 层，主要目的：减少数据库读取负担，提高数据读取速度。cache 存取的媒介是内存，可以考虑采用分布式的 cache 层，这样更容易破除内存容量的限制，同时增加了灵活性。
2） 增加 Redis 缓存数据库
3） 增加数据库索引
4） 页面静态化：
    效率最高、消耗最小的就是纯静态化的 html 页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
    用户可以直接获取页面，不用像 MVC 结构走那么多流程，比较适用于页面信息大量被前台程序调用，但是更新频率很小的情况。
5） 使用存储过程：
    处理一次请求需要多次访问数据库的操作，可以把操作整合到储存过程，这样只要一次数据库访问就可以了。
6） MySQL 主从读写分离：
    当数据库的写压力增加，cache 层（如 Memcached）只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负。使用主从复制技术（master-slave 模式）来达到读写分离，以提高读写性能和读库的可扩展性。读写分离就是只在主服务器上写，只在从服务器上读，基本原理是让主数据库处理事务性查询，而从数据库处理 select 查询，数据库复制被用于把事务性查询（增删改） 导致的改变更新同步到集群中的从数据库。

    MySQL 读写分离提升系统性能：
    1、主从只负责各自的读和写，极大程度缓解 X 锁和 S 锁争用。
    2、slave 可以配置 MyISAM 引擎，提升查询性能以及节约系统开销。
    3、master 直接写是并发的，slave 通过主库发送来的 binlog 恢复数据是异步的。
    4、slave 可以单独设置一些参数来提升其读的性能。
    5、增加冗余，提高可用性。
    实现主从分离可以使用 MySQL 中间件如：Atlas

7） 分表分库：
在 cache 层的高速缓存，MySQL 的主从复制，读写分离的基础上，这时 MySQL 主库的写压力开始出现瓶颈，而数据量的持续猛增，由于 MyISAM 使用表锁，在高并发下会出现严重的锁问题，大量的高并发 MySQL 应用开始使用 InnoDB 引擎代替 MyISAM。
采用 Master-Slave 复制模式的 MySQL 架构，只能对数据库的读进行扩展，而对数据的写操作还是集中在 Master 上。这时需要对数据库的吞吐能力进一步地扩展，以满足高并发访问与海量数据存储的需求。
对于访问极为频繁且数据量巨大的单表来说，首先要做的是减少单表的记录条数，以便减少数据查询所需的时间，提高数据库的吞吐，这就是所谓的分表【水平拆分】。
在分表之前，首先需要选择适当的分表策略（尽量避免分出来的多表关联查询），使得数据能够较为均衡地分布到多张表中，并且不影响正常的查询。
分表能够解决单表数据量过大带来的查询效率下降的问题，但是却无法给数据库的并发处理能力带来质的提升。
面对高并发的读写访问，当数据库 master 服务器无法承载写操作压力时，不管如何扩展 Slave 服务器都是没有意义的，对数据库进行拆分，从而提高数据库写入能力，即分库【垂直拆分】。

8） 负载均衡集群：
将大量的并发请求分担到多个处理节点。
由于单个处理节点的故障不影响整个服务，负载均衡集群同时也实现了高可用性。
负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。


#### 4.Redis 数据库，内容是以何种结构存放在 Redis 中的？
```
String（字符串）
Hash（哈希）
List（列表）
Set（集合）
zset（sortedset：有序集合）
```

#### 5. Redis 的并发竞争问题怎么解决？
> `方案一`：可以使用独占锁的方式，类似操作系统的 mutex 机制，不过实现相对复杂，成本较高。  
> `方案二`：使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）

> 如何用乐观锁方式进行解决？
本质上是假设不会进行冲突，使用 redis 的命令 watch 进行构造条件

#### 6. MySQL 和 Redis 高可用性体现在哪些方面？
> a) MySQL Replication 是 MySQL 官方提供的主从同步方案，用于将一个 MySQL 实例的数据，同步到另一个实例中。Replication 为保证数据安全做了重要的保证，也是现在运用最广的 MySQL 容灾方案。Replication 用两个或以上的实例搭建了 MySQL 主从复制集群， 提供单点写入，多点读取的服务，实现了读的 scale out。

> b) Sentinel 是 Redis 官方为集群提供的高可用解决方案。在实际项目中可以使用 sentinel 去做 Redis 自动故障转移，减少人工介入的工作量。另外 sentinel 也给客户端提供了监控消息的通知，这样客户端就可根据消息类型去判断服务器的状态，去做对应的适配操作。

> c) 下面是 Sentinel 主要功能列表：
```
# Monitoring
Sentinel 持续检查集群中的 master、slave 状态，判断是否存活。

# Notification
在发现某个 Redis 实例死的情况下，Sentinel 能通过 API 通知系统管理员或其他程序脚本。

# Automatic failover
如果一个 master 挂掉后，sentinel 立马启动故障转移，把某个 slave 提升为 master。其他的 slave 重新配置指向新 master。

# Configuration provider
对于客户端来说 sentinel 通知是有效可信赖的。客户端会连接 sentinel 去请求当前 master 的地址，一旦发生故障 sentinel 会提供新地址给客户端。
```

#### 6. Redis 集群实现？
> 需要结合真实案例去分析，这里给大家推荐一个不错的博客。  
https://blog.csdn.net/yfkiss/article/details/38944179

#### 7. Redis 和 MongoDB 的优缺点

MongoDB 和 Redis 都是 NoSQL，采用结构型数据存储。
二者在使用场景中，存在一定的区别，这也主要由于二者在内存映射的处理过程，持久化的处理方法不同。
MongoDB 建议集群部署，更多的考虑到集群方案，Redis 更偏重于进程顺序写入，虽然支持集群，也仅限于主 - 从模式。

Redis 优点：
    1) 读写性能优异
    2) 支持数据持久化，支持 AOF 和 RDB 两种持久化方式
    3) 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
    4) 数据结构丰富：数据结构丰富：支持 string、hash、set、sortedset、list 等数据结构。

缺点：
    1) Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。
    2) 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。
    3) Redis 的主从复制采用全量复制，复制过程中主机会 fork 出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦。
    4) Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题， 运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

MongoDB 优点:
    1）弱一致性（最终一致），更能保证用户的访问速度
    2）文档结构的存储方式，能够更便捷的获取数
    3）内置 GridFS，高效存储二进制大对象 (比如照片和视频)
    4）支持复制集、主备、互为主备、自动分片等特性
    5） 动态查询
    6）全索引支持，扩展到内部对象和内嵌数组

缺点：
1）不支持事务
2）MongoDB 占用空间过大
3）维护工具不够成熟

#### 8. Redis 的事务？
一、Redis 事务允许一组命令在单一步骤中执行。事务有两个属性，说明如下：
a) 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
b) Redis 事务是原子的。原子意味着要么所有的命令都执行，要么都不执行；

二、一个事务从开始到执行会经历以下三个阶段：
a) 开始事务
b) 命令入队
c) 执行事务

#### 9. Redis 的使用场景有哪些？
    1. 取最新 N 个数据的操作
    2. 排行榜应用，取 TOP N 操作
    3. 需要精准设定过期时间的应用
    4. 计数器应用
    5.uniq 操作，获取某段时间所有数据排重值
    6.Pub/Sub 构建实时消息系统
    7. 构建队列系统
    8. 缓存

#### 10. Redis 默认端口，默认过期时间，Value 最多可以容纳的数据长度？
    1. 默认端口：`6379`
    2. 默认过期时间：可以说永不过期，一般情况下，当配置中开启了超出最大内存限制就写磁盘的话， 那么没有设置过期时间的 key 可能会被写到磁盘上。假如没设置，那么 REDIS 将使用 LRU 机制，将内存中的老数据删除，并写入新数据。
    3.Value 最多可以容纳的数据长度是：512M。

#### 11. Redis 有多少个库？
Redis 一个实例下有 16 个。

##### 12.redis 中的 sentinel (哨兵模式) 的作用？
在哨兵模式下，如果主机宕机了，会在从机里面投票选出一个从机当主机，之后如果原来的主机又回来了，在较短的时间内还没有被哨兵模式监控到的时候，回来的主机就是自己一个人单独一套体系自己是光杆司令，但是一会儿功夫，哨兵模式监控到了这个重启的主机后，哨兵模式会告诉这个新来的主机，已经换老大了，你需要跟着新老大混，这个时候新来的就会自动变为从机依附于前面投票选出来的主机
