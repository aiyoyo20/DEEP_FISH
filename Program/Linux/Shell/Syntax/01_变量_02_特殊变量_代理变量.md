之前错误的认为 `export http_proxy=proto://domain:port` 设置的代理会成为终端模拟器或是相应的shell（bash、zsh）的配置，让整个终端都使用代理。或者是这个变量是写入应用层甚至内核层面让代理生效。

实际上都不是。仅仅是一个普通的环境变量。当使用其他命令时，这个变量会被读取。如果有设置则会被应用。这时候这个代理才生效。

代理的生效是命令和代理直接的交互，而没有中间层的过程。

所以看到变量设置有 `export HTTP_PROXY=proto://domain:port`，也有 `export http_proxy=proto://domain:port` 的原因就是相应的软件遵循的方式不同。比如 `curl` 是大小写都可以的。而 `wget` 则只支持小写。

而且 `curl` 可以使用 `all_proxy` 设置代理。而 `wget` 却对这个变量不支持。

所以当终端设置了代理变量，但是实际使用应用时发现代理没有生效。可以去查询一下这个命令的文档是否支持这个变量。是否使用其他的方式，比如传递参数来设置代理。

几种常见命令对应的代理变量参数支持的方式：

|变量名               |curl   |wget    |Ruby        |Python                             |go|
|---------------------|-------|--------|-------------|-----------------------------------|---|
|http_proxy（小写）    |是的    | 是的      |是的         |是的                                 |是的|
|HTTP_PROXY（大写）    |不      |不       |是（警告）  |是（如果 REQUEST_METHOD 不在环境中） |是的|
|https_proxy（小写）   |是的    | 是的      |是的         |是的                                 |是的|
|HTTPS_PROXY（大写）   |是的    | 不       |是的         |是的                                 |是的|
|no_proxy （小写）     |是的    | 是的      |是的         |是的                                 |是的|
|NO_PROXY （大写）     |是的    | 不       |是的         |是的                                 |是的|
|大小写优先            |小写    | 仅小写     |小写         |小写                                 |大写|


`all_proxy` 、`ALL_PROXY` 在不同的软件中使用方式不同。可能是所有协议都支持的方式、也可能只支持某些协议。

`no_proxy` 、`NO_PROXY` 不常见。不同的软件对这个变量的支持不同。他的作用是用来指定不使用代理的域名。多个域名用逗号分隔。