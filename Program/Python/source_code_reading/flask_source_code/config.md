```
class Config(dict):

    def __init__(self, root_path: str, defaults: t.Optional[dict] = None) -> None:
        dict.__init__(self, defaults or {})
        self.root_path = root_path
```

这步的迷惑主要在于，如果是其他自定义类，`dict.__init__(self, defaults or {})` 其实就是将父类的初始变量用在当前类，但是普通类使用后使用`__dict__`方法能看到拥有的实例变量，而这个没有，但是能正常取字典的值。

其最根本的是当一个类继承 dict 时,该类的实例就变成了一个字典,不再需要 `__dict__` 属性来存储实例变量的值, 因为值可以直接存储在实例自身中,就像一个字典一样。

除了字典外,以下几种类型也没有 __dict__ 属性:

	1. 列表:列表是一种序列类型,用于存储值,所以也不需要 __dict__ 属性,值直接存储在列表对象内部。

	2. 集合:集合是一种无序不重复元素集,也是直接存储值的容器,所以也没有 __dict__ 属性。

	3. 元组:元组的值也直接存储在元组对象内部,所以元组没有 __dict__ 属性。

	4. 范围(range):范围对象直接存储 start, stop 和 step 值,所以也没有 __dict__ 属性。

	5. 数组(numpy.array):数组也是一种直接存储值的容器,所以没有 __dict__ 属性。

除此之外,以下类型有 __dict__ 属性:

	1. 实例对象:实例变量的值存储在 __dict__ 属性中。

	2. 类:类变量的值存储在 __dict__ 属性中。

	3. 模块:模块级变量存储在模块对象的 __dict__ 属性中。

- 直接存储值的容器类型(列表、字典、集合、元组等)没有 __dict__ 属性,因为不需要它。
- 实例、类和模块这样的可变容器需要 __dict__ 属性来存储变量的值。
- 不可变类型(整数、字符串、布尔值等)没有 __dict__ 属性,因为无法存储变量。

综上,不是所有的类型都没有 __dict__ 属性,只有直接存储其他值的容器类型, 如列表、字典、集合等,因为它们本身就是一个 "存储值的容器"。其他的对象,如实例、类和模块,需要 __dict__ 来作为"存储值的容器"使用,所以具有 __dict__ 属性。